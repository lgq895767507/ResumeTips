#### 线程安全的实现方法

* 互斥同步
  * synchronization 
    * 原理：反编译出来，线程执行monitorenter指令时尝试获取monitor(监视器锁)的所有权，当线程进入monitor，则monitor进入数+1,monitorexit执行的时候，monitor进入数-1,如果mointor进入数为0的时候，说明线程退出了monitor。
    * synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。


  * ReentrantLock(重入锁)
* 非阻塞同步
  * CAS(compare-and-swap) --原子操作类：AtomicInteger
* 无同步方案
  * 线程本地存储(Thread Local Storage)
  * ThreadLocal类中，每个线程的Thread对象都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的k-v值对，也即是每一个ThreadLocal对象都包含一个threadLocalHashCode值，通过这个就能找到本地线程变量。

#### 线程
##### 线程的5种状态(p384)
* 新建(New):创建后尚未启动
* 运行(Runnable)：操作系统线程状态中的Running和Ready,有可能正在执行，也有可能在等待CPU为它分配执行时间
* 无限期等待(Waiting)：不会被分配CPU执行时间，他们需要等待其他线程显示地唤醒
* 限期等待(Timed Waiting)：不会被分配CPU执行时间，一定时间后由系统自动唤醒
* 阻塞(Blocked):等待获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生
* 结束(Terminated):已终止线程的线程状态，线程已经结束执行。



#### 死锁的四个必要条件
* 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
* 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
* 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
* 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系

四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

#### 死锁预防
我们可以通过破坏死锁产生的4个必要条件来 预防死锁，由于资源互斥是资源使用的固有特性是无法改变的。
* 破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。
* 破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。
* 破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。

#### wait和sleep的区别
* 