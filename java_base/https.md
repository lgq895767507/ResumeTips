## http,https网络相关

#### http概念
HTTP协议是超文本传输协议，HTTP是一个基于TCP/IP通信协议来传递数据。

#### http消息结构
* HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。
* 客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。

![avatar](../img/http0.png)

* 默认使用端口80


#### https
* 超文本传输安全协议，HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。
* 默认使用端口443

#### https加密流程
1. client给出协议版本号，一个随机数，以及客户端支持的加密方法。
2. server端确认加密方法，并且给出数字证书，服务端生成一个随机数
3. client确认数字证书有效，然后生成一个新的随机数，并且使用证书中的公钥，对随机数进行加密，发给服务端
4. 服务端使用自己的私钥，获取client发来的随机数
5. client和server根据约定的加密算法，使用前面的三个随机数，生成“对话密钥”(session key)，用来加密接下来的整个对话过程。

#### session的恢复
* 握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。这时有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。

* session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的"对话密钥"，而不必重新生成一把。

* session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。
* session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。
* session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。

基于tcp的socket编程技术



#### Socket
socket是应用层与传输层的一个抽象，http是应用层，tpc/udp是传输层，socket基于TCP协议，是全双工的。


#### http的版本
* HTTP/2 相比于 HTTP/1.1，可以说是大幅度提高了网页的性能

##### [HTTP/1.1的缺陷](https://blog.csdn.net/howgod/article/details/102597450)
1. 高延迟--带来页面加载速度的降低
  * 网络延迟问题主要由于队头阻塞,导致带宽无法被充分利用。队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。人们尝试过以下办法来解决：
     * 将同一页面的资源分散到不同域名下，提升连接上限。
     * 内联(Inlining)是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数
2. 无状态特性--带来的巨大HTTP头部
   * head携带的内容过大
3. 明文传输--带来的不安全性
4. 不支持服务器推送消息

总结： HTTP/1.1有两个主要的缺点：安全不足和性能不高

#### HTTP/2 
1. 概念：HTTP/2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）。
2. HTTP/2传输数据量的大幅减少,主要有两个原因：
   * 以二进制方式传输
   * Header 压缩
3. [多路复用](https://cloud.tencent.com/developer/article/1573513)
   * 在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题
4. 同域名下所有通信都在单个连接上完成
5. 单个连接可以承载任意数量的双向数据流
6. 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装
7. Server Push
   * 服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息
8. 提高安全性

#### HTTP/2 的缺点
1. TCP 以及 TCP+TLS建立连接的延时
2. TCP的队头阻塞并没有彻底解决

#### HTTP/3
1. 基于UDP 协议的“QUIC”协议

#### QUIC新功能
1. 实现了类似TCP的流量控制、传输可靠性的功能
2. 实现了快速握手功能
3. 集成了TLS加密功能
4. 多路复用，彻底解决TCP中队头阻塞的问题


#### [tcp拆包和粘包](https://www.cnblogs.com/cangqinglang/p/11503057.html)
1. 在TCP的socket编程中，发送端和接收端都有成对的socket
2. 发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包
3. 那么这样一来，接收端就必须使用高效科学的拆包机制来分辨这些数据

##### 造成TCP粘包的原因
1. 发送方原因
   * TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：只有上一个分组得到确认，才会发送下一个分组,收集多个小分组，在一个确认到来时一起发送,Nagle算法造成了发送方可能会出现粘包问题
2. 接收方原因
   * 如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

##### 如何处理粘包现象
1. 发送方
   * 对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。
2. 接收方
   * 接收方没有办法来处理粘包现象，只能将问题交给应用层来处理
3. 应用层
   * 循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成

#### [TCP如何保证传输可靠性](https://blog.csdn.net/cbjcry/article/details/84925028)
1. 校验和
   * 计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。 
   * 发送方：在发送数据之前计算检验和，并进行校验和的填充。 
   * 接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对
2. 确认应答与序列号
   * 序列号：TCP传输时将每个字节的数据都进行了编号
3. 超时重传
   *  当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 
4. 流量控制
   *  接收方有即时窗口（滑动窗口），随ACK报文发送
5. 拥塞控制
   * 慢启动、拥塞避免、拥塞发送、快速恢复